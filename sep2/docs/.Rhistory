q()
test1 <- c(6,10,6,10,5,3,5,9,3,3,11,6,11,9,7,5,8,7,7,9)
length(test1)
test2 <- c(10,13,8,15,8,6,9,10,7,3,18,14,18,11,12,5,7,12,7,7)
length(test2)
corr1 <- corr(test1,test2)
corr1 <- cor(test1,test2)
corr1
cor.test(test1,test2)
exit
quit
quit()
test1
quit()
   TeaTasting <-
   matrix(c(3, 1, 1, 3), nr = 2, dimnames = list(Guess = c("Milk", "Tea"),
         Truth = c("Milk", "Tea")))
   fisher.test(TeaTasting, alternative = "greater")
TeaTasting2 <- matrix(c{4,0,0,4), nr-2, dimnames = list(Guess = c("Milk", "Tea"),Truth = c("Milk", "Tea")))
TeaTasting2 <- matrix(c(4,0,0,4), nr-2, dimnames = list(Guess = c("Milk", "Tea"),Truth = c("Milk", "Tea")))
TeaTasting2 <- matrix(c(4,0,0,4), nr=2, dimnames = list(Guess = c("Milk", "Tea"),Truth = c("Milk", "Tea")))
fisher.test(TeaTasting2, alternative = "greater")
choose(8,4)
moltTest <- matrix(c(36,36,21,48),nr=2, dimnames = list(Guess=c("Malts","Blends"),Truth=c("Malts","Blends")))
fisher.test(moltTest, alternative = "greater")
fisher.test(moltTest)
moltTest <- matrix(c(36,39,24,48),nr=2, dimnames = list(Guess=c("Malts","Blends"),Truth=c("Malts","Blends")))
fisher.test(moltTest, alternative="greater")
moltTest <- matrix(c(36,36,24,48),nr=2, dimnames = list(Guess=c("Malts","Blends"),Truth=c("Malts","Blends")))
fisher.test(moltTest, alternative="greater")
fisher.test(moltTest)
moltTest2 <- matrix(c(32,39,33,40),nr=2, dimnames = list(Guess=c("Malts","Blends"),Truth=c("Malts","Blends")))
fisher.test(moltTest2, alternative="greater")
fisher.test(moltTest2)
matrix(1:6,nc=2)
matrix(1:6,nr=2)
moltTest <- matrix(c(36,24,36,48),nr=2, dimnames = list(Guess=c("Malts","Blends"),Truth=c("Malts","Blends")))
fisher.test(moltTest, alternative="greater")
fisher.test(moltTest)
moltTest2 <- matrix(c(32,33,39,40),nr=2, dimnames = list(Guess=c("Malts","Blends"),Truth=c("Malts","Blends")))
fisher.test(moltTest2, alternative="greater")
fisher.test(moltTest2)
crosstab(moltTest1)
moltTest1
moltTest
moltTest2
fisher.test(moltTest)
fisher.test(moltTest2)
moltTest <- matrix(c(36,24,36,48),nr=2, dimnames = list(Truth=c("Malts","Blends"),Guess=c("Malts","Blends")))
moltTest
moltTest2 <- matrix(c(32,33,39,40),nr=2, dimnames = list(Truth=c("Malts","Blends"),Guess=c("Malts","Blends")))
moltTest2
fisher.test(moltTest)
fisher.test(moltTest2)
quit()
install.packages("iterators")
install.packages("/home/yutakashino/Dropbox/sandboxDrop/math/iterators_1.0.1.tgz", mac.binary)
install.packages("/home/yutakashino/Dropbox/sandboxDrop/math/iterators_1.0.1.tgz")
install.packages("/Users/yutakashino/Dropbox/sandboxDrop/math/iterators_1.0.1.tgz")
install.packages("/Users/yutakashino/Dropbox/sandboxDrop/math/iterators_1.0.1.tgz", repos=null)
library(iterators)
y
a <- array(1:8, c(2,2,2))
it <- iapply(a,3)
as.list(it)
it <- iapply(a,c(2,3))
as.list(it)
it <- irnorm(1, count=3)
nextElem(it)
i1 <- iter(1:3)
nextElem(i1)
try(nextElem(it))
library(foreach)
x <- foreach(i = 1:3) %do% sqrt(i)
sqrt(3)
x <- foreach(i=1:3) %do% sqrt(i)
x <- foreach(a = 1:3, b = rep(10, 3)) %do% (a + b)
x <- foreach(a = 1:3, b = rep(10, 3)) (a + b)
install.packages(codetools)
x <- foreach(i=1:3) %do% sqrt(i)
library(LearnBayes)
install.packages(LearnBayes)
install.packages("LearnBayes")
library("LearnBayes")
{
q;
}
appetizer.solution <- local (#
function (target) {#
  app <- c(2.15, 2.75, 3.35, 3.55, 4.20, 5.80)#
  r <- 2L#
  repeat {#
	c <- gtools::combinations(length(app), r=r, v=app, repeats.allowed=TRUE)#
	s <- rowSums(c)#
	if ( all(s > target) ) {#
	  print("No solution found")#
	  break#
	}#
	x <- which( abs(s-target) < 1e-4 )#
	if ( length(x) > 0L ) {#
	  print("Solution found")#
	  print(c[x,])#
	  break#
	}#
	r <- r + 1L#
  }#
})#
appetizer.solution(15.05)
install.packages(gtools)
install.package
install.packages
install.packages("gdata")
install.packages("gtools")
appetizer.solution <- local (#
function (target) {#
  app <- c(2.15, 2.75, 3.35, 3.55, 4.20, 5.80)#
  r <- 2L#
  repeat {#
	c <- gtools::combinations(length(app), r=r, v=app, repeats.allowed=TRUE)#
	s <- rowSums(c)#
	if ( all(s > target) ) {#
	  print("No solution found")#
	  break#
	}#
	x <- which( abs(s-target) < 1e-4 )#
	if ( length(x) > 0L ) {#
	  print("Solution found")#
	  print(c[x,])#
	  break#
	}#
	r <- r + 1L#
  }#
})#
appetizer.solution(15.05)
gtools::combinations(length(app),r=r, v=app, repeats.allowed=TRUE)
app
app <- c(2.15, 2.75, 3.35, 3.55, 4.20, 5.80)
r <- 2L
gtools::combinations(length(app), r=r, v=app, repeats.allowed=TRUE)
rowSums(c)
c <- gtools::combinations(length(app), r=r, v=app, repeats.allowed=TRUE)
rowSums(c)
r + 1L
gtools::combinations(length(app), r=3, v=app, repeats.allowed=TRUE)
combinations(3,2,letters[1:3])
gtools::combinations(3,2,letters[1:3])
8
gtools::combinations(3,2,letters[1:8])
gtools::combinations(8,4,letters[1:8])
gtools::combinations(5,3,letters[1:5])
gtools::permutations(5,3,letters[1:5])
ls()
integrand <- function(x) {1/((x+1)*sqrt(x))}
integrand
integrand(3)
integrate(integrand, lower = 0, upper = Inf)
integrate(integrand, lower = 0, upper = 10)
?apply
?lapply
q()
map <- new.env(hash=TRUE)
assign('dog',7,map)
ls(map)
x <- 'dog'
x
ls(map)
get(x,map)
map
counts < - c(18,17,15,20,10,20,25,13,12)
counts <- c(18,17,15,20,10,20,25,13,12)
outcome <- gl(3,1,9)
treatment <- gl(3,3)
glm.D93 <- glm(counts ~ outcome +treatment, family=poisson())
glm.D93
model <- unclass(glm.D93)
model
glm.D93.summary()
summary(glm.D93)
seq(-0.5,8.5,1)
load("/Users/yutakashino/sandbox/mcmcworks/kubo2009/d.RData")
print(d)
install.library(epitools)
install.packages(epitools)
install.packages("epitools")
q()
library("robustbase")
data(table.b13,package="MPV")
Jet <- table.b13
lr <- lmrob(y~x3, data=Jet)
summary(lr)
x3
Jet
plot(y~x3,data=Jet)
abline(lmrob(y~x3,data=jet))
abline(lmrob(y~x3,data=Jet))
ls()
rm(list = ls(all = TRUE))
ls()
rm(ls())
rm(list=ls())
ls()
q()
demo()
demo(image)
install.packages("RCurl")
library(RCurl)#
# example from the vignette:#
x = postForm('http://www.wormbase.org/db/searches/advanced/dumper', #
  species="briggsae", #
  list="", #
  flank3="0", #
  flank5="0", #
  feature="Gene Models", #
  dump = "Plain TEXT", #
  orientation = "Relative to feature", #
  relative = "Chromsome", #
  DNA ="flanking sequences only", #
  .cgifields =c("feature", "orientation", "DNA", "dump", "relative"))
x
library(ggplot2)
library(HSAU2)
install.packages("HSAU2")
library(HSAUR2)
library(XML)
download.file("http://euler.bakfoo.com/jleagers.rda", "jleagers.rda")
download.file("http://euler.bakfoo.com/public/jleagers.rda", "jleagers.rda")
load("jleagers.rda")
ls
ls()
data.jleagers
getwd()
conn <- url("http://euler.bakfoo.com/public/jleagers.rda")
load(conn)
ls()
data.jleagers
conn <- url("http://euler.bakfoo.com/public/japanpop.rda")#
load(conn)
ls()
x <- co2#
y <- fft(x)#
y[20:(length(y)-19)] <- 0#
y <- Re(fft(y, inverse=T)/length(y))#
plot(x, type='l')#
lines(y, col='red', lwd=3)
spectrum(co2)#
abline(v=1:10, lty=3)
signal.and.spectrum <- function (x, main="") {#
  op <- par(mfrow=c(2,1), #
            mar=c(2,4,2,2)+.1,#
            oma=c(0,0,2,0))#
  plot(x, type="l", main="", ylab="Signal")#
  spectrum(x, main="", xlab="")#
  abline(v=.1*1:10, lty=3)#
  par(op)#
 mtext(main, line=1.5, font=2, cex=1.2)#
}#
N <- 100#
x <- 10 * (1:N / N)#
signal.and.spectrum(sin(2*pi*x), #
                    "Sine wave, period=10")
signal.and.spectrum(x - floor(x), #
                    "sawtooth, period=10")
data(sunspots)#
plot(sunspots)
a <- locator() # click on the local maxima#
b <- a$x - a$x[1]#
bb <- outer(b, 9:13, '/')#
apply(abs(bb - round(bb)), 2, mean)
n <- 1000#
x <- cumsum(rnorm(n))+rnorm(n)#
y <- fft(x)#
y[20:(length(y)-19)] <- 0#
y <- Re(fft(y, inverse=T)/length(y))#
op <- par(mfrow=c(3,1), mar=c(3,4,2,2)+.1)#
plot(x, type='l', #
     main="FFT: Removing the high frequencies from a signal")#
lines(y, col='red', lwd=3)#
plot(Mod(fft(x)[1: ceiling((length(x)+1)/2) ]), #
     type='l', ylab="FFT")#
plot(Mod(fft(y)[1: ceiling((length(y)+1)/2) ]), #
     type='l', ylab="Truncated FFT")#
par(op)
colorie <- function (x, y1, y2, N=1000, ...) {#
  for (t in (0:N)/N) {#
    lines(x, t*y1+(1-t)*y2, ...)#
  }#
}#
# No, there is already a function to do this#
colorie <- function (x, y1, y2, ...) {#
  polygon( c(x, x[length(x):1]), c(y1, y2[length(y2):1]), ... )#
}#
x <- seq(-6,6, length=100)#
y <- dnorm(x)#
plot(y~x, type='l')#
i = x<qnorm(.025)#
colorie(x[i],y[i],rep(0,sum(i)) ,col='red')#
i = x>qnorm(.975)#
colorie(x[i],y[i],rep(0,sum(i)) ,col='red')#
lines(y~x)#
title(main="Type I error")
plot(y~x, type='l')
i = x<qnorm(.025)
colorie(x[i],y[i],rep(0,sum(i)) ,col='red')
colorie <- function (x, y1, y2, ...) {#
  polygon( c(x, x[length(x):1]), c(y1, y2[length(y2):1]), ... )#
}
colorie(x[i],y[i],rep(0,sum(i)) ,col='red')
i = x>qnorm(.975)
colorie(x[i],y[i],rep(0,sum(i)) ,col='red')
line(y-x)
lines(y-x)
curve(dchisq(x,3), from =0, to=100, add=T, col=col[3])
curve(dchisq(x,3), from=0,to=10,col="red")
n <- 15#
col <- rainbow(n)#
for (i in 1:n){#
    curve(dchisq(x,i), from=0, to=100, add=T, col=col[i])#
}
old <- par(new=TRUE) #
n <- 15#
col <- rainbow(n)#
for (i in 1:n){#
    curve(dchisq(x,i), from=0, to=100, add=TRUE, col=col[i])#
}#
par(old)
setwd("/Users/yutakashino/Dropbox/sandboxDrop/@IT/temp/")#
afg<-read.csv("afg.csv",stringsAsFactors=FALSE)
head(afg)
head(afg, 10)
less(afg)
tail(afg)
str(afg)
head(afg)
colnames(afg)<-c("ReportKey", "DateOccurred", "Type", "Category", "TrackingNumber", "Title", "Summary", "Region", "AttackOn", "ComplexAttack", "ReportingUnit", "UnitName", "TypeOfUnit", "FriendlyWIA", "FriendlyKIA", "HostNationWIA", "HostNationKIA", "CivilianWIA", "CivilianKIA", "EnemyWIA", "EnemyKIA", "EnemyDetained", "MGRS", "Latitude", "Longitude", "OriginatorGroup",  "UpdatedByGroup", "CCIR", "Sigact", "Affiliation", "DColor", "Classification")
head(afg)
afg$DateOccurred <- as.Date(afg$DateOccurred)
afg$Region<-as.factor(afg$Region)
library(ggplot2)#
event <- ggplot( afg, aes(x = DateOccurred) ) + stat_bin( aes( y = ..count.., fill = AttackOn ), binwidth=30 ) + facet_wrap( ~Region ) + #
    opts( title = "Monthly Event Report (Region and Attack Target)" ) + xlab( "Date ") + ylab( "Report Counts" ) + #
    scale_fill_manual( values = c( "darkred", "darkblue", "darkgreen", "orange" ), name = "Who Attacked" ) + scale_x_date( major = "years", minor = "months" )
event
ggplot( afg, aes(x = DateOccurred) ) + stat_bin( aes( y = ..count..), binwidth=30 ) + facet_wrap( ~Region ) + #
    opts( title = "Monthly Event Report (Region and Attack Target)" ) + xlab( "Date ") + ylab( "Report Counts" ) + #
    scale_fill_manual( values = c( "darkred", "darkblue", "darkgreen", "orange" ), name = "Who Attacked" ) + scale_x_date( major = "years", minor = "months" )
tail(afg)
setwd("/Users/yutakashino/Dropbox/sandboxDrop/@IT/sandbox/sep2/docs/")
event <- ggplot( afg, aes(x = DateOccurred) ) + stat_bin( aes( y = ..count.., fill = AttackOn ), binwidth=30 ) + facet_wrap( ~Region ) + #
    opts( title = "Monthly Event Report (Region and Attack Target)" ) + xlab( "Date ") + ylab( "Report Counts" ) + #
    scale_fill_manual( values = c( "darkred", "darkblue", "darkgreen", "orange" ), name = "Who Attacked" ) + scale_x_date( major = "years", minor = "months" )
event <- ggplot( afg, aes(x = DateOccurred) ) + stat_bin( aes( y = ..count.., fill = AttackOn ), binwidth=30 ) + facet_wrap( ~Region ) + #
    opts( title = "Monthly Event Report per Region and Target" ) + xlab( "Date") + ylab( "Report Counts" ) + #
    scale_fill_manual( values = c( "darkred", "darkblue", "darkgreen", "orange" ), name = "AttackOn" ) + scale_x_date( major = "years", minor = "months" )
ggsave("wikileaks_event.png", plot = event, width=10, height=5)
weeklyCount<-cbind(table(cbind(format.Date(afg$DateOccurred,"%Y %W"))))
dbenford <- function(x) {#
    return(log10((1+x)/x))#
}#
#
pullLeaddigit<-function(x) {#
    as.numeric(substring(formatC(x, format = 'e'), 1, 1))#
} #
#
digits <- table(pullLeaddigit(weeklyCount))#
digits <- cbind(digits)#
digits <- as.data.frame(digits)#
colnames(digits) <- "digitCount"#
digits$digitCount <- digits$digitCount/sum(digits$digitCount)#
#
benford <- ggplot(digits, aes(x=1:9, y=digitCount)) + geom_path(aes(colour = "observation")) + geom_point(aes(colour = "observation")) + stat_function(fun = dbenford, aes(colour = "theory")) + scale_colour_manual( values = c("observation" = "orange", "theory" = "blue")) + xlab("Digit") + ylab("Count Density") + opts(title="Applying Benford's law to Wikileaks Data") #
ggsave("wikileaks_benford.png", plot=benford, width=7, height=7)
head(weeklyCount)
formatC(12)
formatC(12, format="e")
head(pullLeaddigit(weeklyCount))
chisq.test(x= digits$digitCount, y = dbenford(1:9))
chisq.test(digits$digitCount, dbenford(1:9))
